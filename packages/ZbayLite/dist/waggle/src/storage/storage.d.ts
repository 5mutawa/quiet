import { ChannelMessage, PublicChannel, SaveCertificatePayload } from '@zbayapp/nectar';
import * as IPFS from 'ipfs-core';
import Libp2p from 'libp2p';
import OrbitDB from 'orbit-db';
import EventStore from 'orbit-db-eventstore';
import PeerId from 'peer-id';
import { DirectMessagesRepo, PublicChannelsRepo, StorageOptions } from '../common/types';
import IOProxy from '../socket/IOProxy';
export declare class Storage {
    zbayDir: string;
    io: IOProxy;
    peerId: PeerId;
    protected ipfs: IPFS.IPFS;
    protected orbitdb: OrbitDB;
    private channels;
    private messageThreads;
    private certificates;
    publicChannelsRepos: Map<String, PublicChannelsRepo>;
    directMessagesRepos: Map<String, DirectMessagesRepo>;
    options: StorageOptions;
    orbitDbDir: string;
    ipfsRepoPath: string;
    private readonly communityId;
    constructor(zbayDir: string, ioProxy: IOProxy, communityId: string, options?: Partial<StorageOptions>);
    init(libp2p: Libp2p, peerID: PeerId): Promise<void>;
    private __stopOrbitDb;
    private __stopIPFS;
    stopOrbitDb(): Promise<void>;
    protected initIPFS(libp2p: Libp2p, peerID: PeerId): Promise<IPFS.IPFS>;
    createDbForCertificates(): Promise<void>;
    private createDbForChannels;
    private createDbForMessageThreads;
    initAllChannels(): Promise<void>;
    initAllConversations(): Promise<void>;
    protected getAllEventLogEntries<T>(db: EventStore<T>): T[];
    loadAllChannelMessages(channelAddress: string): void;
    subscribeToChannel(channel: PublicChannel): Promise<void>;
    private createChannel;
    askForMessages(channelAddress: string, ids: string[]): Promise<{
        filteredMessages: ChannelMessage[];
        channelAddress: string;
    }>;
    sendMessage(message: ChannelMessage): Promise<void>;
    initializeConversation(address: string, encryptedPhrase: string): Promise<void>;
    subscribeToAllConversations(conversations: any): Promise<void>;
    subscribeToDirectMessageThread(channelAddress: string): Promise<void>;
    private createDirectMessageThread;
    sendDirectMessage(channelAddress: string, message: string): Promise<void>;
    getPrivateConversations(): Promise<void>;
    saveCertificate(payload: SaveCertificatePayload): Promise<boolean>;
    getAllUsers(): any[];
    usernameExists(username: string): boolean;
}
